/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.15.5.0 (NJsonSchema v10.6.6.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import * as ko from 'knockout';

export class ClientApi extends BaseClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: any, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * create address
     * @return Address Informations
     */
    addressCreate(body: RegisterAddress): Promise<any> {
        let url_ = this.baseUrl + "/address/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processAddressCreate(_response));
        });
    }

    protected processAddressCreate(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            return throwException("Invalid informations", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(<any>null);
    }

    /**
     * Modify an address
     * @return Address Informations
     */
    addressUpdate:id(body: RegisterAddress): Promise<any> {
        let url_ = this.baseUrl + "/address/update/:id";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processAddressUpdate:id(_response));
        });
    }

    protected processAddressUpdate:id(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : <any>null;
    
            return result201;
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            return throwException("Invalid informations", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(<any>null);
    }

    /**
     * Get all Address (useless temporaly delete later)
     * @return Addresses Informations
     */
    addressAll(): Promise<any> {
        let url_ = this.baseUrl + "/address/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processAddressAll(_response));
        });
    }

    protected processAddressAll(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : <any>null;
    
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("empty result", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(<any>null);
    }

    /**
     * Get one address
     * @return Address Informations
     */
    addressOne:id(): Promise<any> {
        let url_ = this.baseUrl + "/address/one/:id";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processAddressOne:id(_response));
        });
    }

    protected processAddressOne:id(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(<any>null);
    }

    /**
     * Delete one adress
     * @return Authentification Informations
     */
    addressDelete:id(): Promise<any> {
        let url_ = this.baseUrl + "/address/delete/:id";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processAddressDelete:id(_response));
        });
    }

    protected processAddressDelete:id(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(<any>null);
    }

    /**
     * Create an account
     * @return Account Informations
     */
    authRegister(body: RegisterBody): Promise<UserResponse> {
        let url_ = this.baseUrl + "/auth/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processAuthRegister(_response));
        });
    }

    protected processAuthRegister(response: Response): Promise<UserResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = UserResponse.fromJS(resultData201);
            return result201;
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            return throwException("Invalid informations", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserResponse>(<any>null);
    }

    /**
     * login to your account
     * @return Account Informations
     */
    authLogin(body: LoginBody): Promise<TokenResponse> {
        let url_ = this.baseUrl + "/auth/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processAuthLogin(_response));
        });
    }

    protected processAuthLogin(response: Response): Promise<TokenResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = TokenResponse.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Invalid informations", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TokenResponse>(<any>null);
    }

    /**
     * log out of your account
     * @return Authentification Informations
     */
    authLogout(): Promise<AuthInfos> {
        let url_ = this.baseUrl + "/auth/logout";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processAuthLogout(_response));
        });
    }

    protected processAuthLogout(response: Response): Promise<AuthInfos> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthInfos.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AuthInfos>(<any>null);
    }

    /**
     * status and connection information
     * @return Authentification Informations
     */
    authStatus(): Promise<AuthInfos> {
        let url_ = this.baseUrl + "/auth/status";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processAuthStatus(_response));
        });
    }

    protected processAuthStatus(response: Response): Promise<AuthInfos> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthInfos.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AuthInfos>(<any>null);
    }

    /**
     * Get all department
     * @return success
     */
    departmentAll(): Promise<any> {
        let url_ = this.baseUrl + "/department/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processDepartmentAll(_response));
        });
    }

    protected processDepartmentAll(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(<any>null);
    }

    /**
     * Get one department
     * @return success
     */
    departmentOne:id(): Promise<any> {
        let url_ = this.baseUrl + "/department/one/:id";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processDepartmentOne:id(_response));
        });
    }

    protected processDepartmentOne:id(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(<any>null);
    }

    /**
     * Send a email
     * @return success
     */
    mail(body: Email): Promise<void> {
        let url_ = this.baseUrl + "/mail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processMail(_response));
        });
    }

    protected processMail(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            return throwException("Invalid informations", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Send many email
     * @return success
     */
    mails(body: Emails): Promise<void> {
        let url_ = this.baseUrl + "/mails";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processMails(_response));
        });
    }

    protected processMails(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            return throwException("Invalid informations", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * create role
     * @return Role Informations
     */
    roleCreate(body: RegisterRole): Promise<any> {
        let url_ = this.baseUrl + "/role/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processRoleCreate(_response));
        });
    }

    protected processRoleCreate(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            return throwException("Invalid informations", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(<any>null);
    }

    /**
     * Modify a role
     * @return Role Informations
     */
    roleUpdate:id(body: RegisterRole): Promise<any> {
        let url_ = this.baseUrl + "/role/update/:id";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processRoleUpdate:id(_response));
        });
    }

    protected processRoleUpdate:id(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : <any>null;
    
            return result201;
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            return throwException("Invalid informations", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(<any>null);
    }

    /**
     * Get all Adress (useless temporaly delete later)
     * @return Role Informations
     */
    roleAll(): Promise<any> {
        let url_ = this.baseUrl + "/role/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processRoleAll(_response));
        });
    }

    protected processRoleAll(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : <any>null;
    
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("empty result", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(<any>null);
    }

    /**
     * Get one role
     * @return Role Informations
     */
    roleOne:id(): Promise<any> {
        let url_ = this.baseUrl + "/role/one/:id";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processRoleOne:id(_response));
        });
    }

    protected processRoleOne:id(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(<any>null);
    }

    /**
     * Delete one role
     * @return Role Informations
     */
    roleDelete:id(): Promise<any> {
        let url_ = this.baseUrl + "/role/delete/:id";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processRoleDelete:id(_response));
        });
    }

    protected processRoleDelete:id(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(<any>null);
    }

    /**
     * html link to login or register with google
     * @return success and returns html
     */
    oauth2Google(): Promise<FileResponse> {
        let url_ = this.baseUrl + "/oauth2/google";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "schema"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processOauth2Google(_response));
        });
    }

    protected processOauth2Google(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    /**
     * redirects and opens a google authentication window
     * @return success and show google auth
     */
    oauth2GoogleRedirect(): Promise<void> {
        let url_ = this.baseUrl + "/oauth2/google/redirect";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processOauth2GoogleRedirect(_response));
        });
    }

    protected processOauth2GoogleRedirect(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class RegisterAddress {
    departmentId = ko.observable<number>();
    country = ko.observable<string>();
    city = ko.observable<string>();
    number = ko.observable<number>();
    typeStreet = ko.observable<string>();
    place = ko.observable<string>();
    street = ko.observable<string>();
    created_at = ko.observable<any>();
    updated_at = ko.observable<any>();

    init(data?: any) {
        if (data !== undefined) {
            var departmentId_: any;
                departmentId_ = _data["departmentId"];
            this.departmentId(departmentId_);

            var country_: any;
                country_ = _data["country"];
            this.country(country_);

            var city_: any;
                city_ = _data["city"];
            this.city(city_);

            var number_: any;
                number_ = _data["number"];
            this.number(number_);

            var typeStreet_: any;
                typeStreet_ = _data["typeStreet"];
            this.typeStreet(typeStreet_);

            var place_: any;
                place_ = _data["place"];
            this.place(place_);

            var street_: any;
                street_ = _data["street"];
            this.street(street_);

            var created_at_: any;
                created_at_ = _data["created_at"];
            this.created_at(created_at_);

            var updated_at_: any;
                updated_at_ = _data["updated_at"];
            this.updated_at(updated_at_);

        }
    }

    static fromJS(data: any): RegisterAddress {
        let result = new RegisterAddress();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        let departmentId_: any = this.departmentId();
        data["departmentId"] = departmentId_;

        let country_: any = this.country();
        data["country"] = country_;

        let city_: any = this.city();
        data["city"] = city_;

        let number_: any = this.number();
        data["number"] = number_;

        let typeStreet_: any = this.typeStreet();
        data["typeStreet"] = typeStreet_;

        let place_: any = this.place();
        data["place"] = place_;

        let street_: any = this.street();
        data["street"] = street_;

        let created_at_: any = this.created_at();
        data["created_at"] = created_at_;

        let updated_at_: any = this.updated_at();
        data["updated_at"] = updated_at_;

        return data;
    }
}

export class AddressResponse {
    id = ko.observable<number>();
    departmentId = ko.observable<number>();

    init(data?: any) {
        if (data !== undefined) {
            var id_: any;
                id_ = _data["id"];
            this.id(id_);

            var departmentId_: any;
                departmentId_ = _data["departmentId"];
            this.departmentId(departmentId_);

        }
    }

    static fromJS(data: any): AddressResponse {
        let result = new AddressResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        let id_: any = this.id();
        data["id"] = id_;

        let departmentId_: any = this.departmentId();
        data["departmentId"] = departmentId_;

        return data;
    }
}

export class ExecuteAddress {
    success = ko.observable<string>();
    error = ko.observable<any>();

    init(data?: any) {
        if (data !== undefined) {
            var success_: any;
                success_ = _data["success"];
            this.success(success_);

            var error_: any;
                error_ = _data["error"];
            this.error(error_);

        }
    }

    static fromJS(data: any): ExecuteAddress {
        let result = new ExecuteAddress();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        let success_: any = this.success();
        data["success"] = success_;

        let error_: any = this.error();
        data["error"] = error_;

        return data;
    }
}

export class AuthInfos {
    isLoggedIn = ko.observable<boolean>();
    isGuest = ko.observable<boolean>();
    authenticationAttempted = ko.observable<boolean>();
    isAuthenticated = ko.observable<boolean>();
    user = ko.observable<any>();

    init(data?: any) {
        if (data !== undefined) {
            var isLoggedIn_: any;
                isLoggedIn_ = _data["isLoggedIn"];
            this.isLoggedIn(isLoggedIn_);

            var isGuest_: any;
                isGuest_ = _data["isGuest"];
            this.isGuest(isGuest_);

            var authenticationAttempted_: any;
                authenticationAttempted_ = _data["authenticationAttempted"];
            this.authenticationAttempted(authenticationAttempted_);

            var isAuthenticated_: any;
                isAuthenticated_ = _data["isAuthenticated"];
            this.isAuthenticated(isAuthenticated_);

            var user_: any;
                user_ = _data["user"];
            this.user(user_);

        }
    }

    static fromJS(data: any): AuthInfos {
        let result = new AuthInfos();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        let isLoggedIn_: any = this.isLoggedIn();
        data["isLoggedIn"] = isLoggedIn_;

        let isGuest_: any = this.isGuest();
        data["isGuest"] = isGuest_;

        let authenticationAttempted_: any = this.authenticationAttempted();
        data["authenticationAttempted"] = authenticationAttempted_;

        let isAuthenticated_: any = this.isAuthenticated();
        data["isAuthenticated"] = isAuthenticated_;

        let user_: any = this.user();
        data["user"] = user_;

        return data;
    }
}

export class TokenResponse {
    type = ko.observable<string>();
    token = ko.observable<string>();
    expires_at = ko.observable<any>();

    init(data?: any) {
        if (data !== undefined) {
            var type_: any;
                type_ = _data["type"];
            this.type(type_);

            var token_: any;
                token_ = _data["token"];
            this.token(token_);

            var expires_at_: any;
                expires_at_ = _data["expires_at"];
            this.expires_at(expires_at_);

        }
    }

    static fromJS(data: any): TokenResponse {
        let result = new TokenResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        let type_: any = this.type();
        data["type"] = type_;

        let token_: any = this.token();
        data["token"] = token_;

        let expires_at_: any = this.expires_at();
        data["expires_at"] = expires_at_;

        return data;
    }
}

export class LoginBody {
    email = ko.observable<string>();
    password = ko.observable<string>();

    init(data?: any) {
        if (data !== undefined) {
            var email_: any;
                email_ = _data["email"];
            this.email(email_);

            var password_: any;
                password_ = _data["password"];
            this.password(password_);

        }
    }

    static fromJS(data: any): LoginBody {
        let result = new LoginBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        let email_: any = this.email();
        data["email"] = email_;

        let password_: any = this.password();
        data["password"] = password_;

        return data;
    }
}

export class RegisterBody {
    email = ko.observable<string>();
    username = ko.observable<string>();
    password = ko.observable<string>();
    password_confirmation = ko.observable<string>();

    init(data?: any) {
        if (data !== undefined) {
            var email_: any;
                email_ = _data["email"];
            this.email(email_);

            var username_: any;
                username_ = _data["username"];
            this.username(username_);

            var password_: any;
                password_ = _data["password"];
            this.password(password_);

            var password_confirmation_: any;
                password_confirmation_ = _data["password_confirmation"];
            this.password_confirmation(password_confirmation_);

        }
    }

    static fromJS(data: any): RegisterBody {
        let result = new RegisterBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        let email_: any = this.email();
        data["email"] = email_;

        let username_: any = this.username();
        data["username"] = username_;

        let password_: any = this.password();
        data["password"] = password_;

        let password_confirmation_: any = this.password_confirmation();
        data["password_confirmation"] = password_confirmation_;

        return data;
    }
}

export class UserResponse {
    id = ko.observable<number>();
    email = ko.observable<string>();
    username = ko.observable<string>();
    created_at = ko.observable<any>();
    updated_at = ko.observable<any>();

    init(data?: any) {
        if (data !== undefined) {
            var id_: any;
                id_ = _data["id"];
            this.id(id_);

            var email_: any;
                email_ = _data["email"];
            this.email(email_);

            var username_: any;
                username_ = _data["username"];
            this.username(username_);

            var created_at_: any;
                created_at_ = _data["created_at"];
            this.created_at(created_at_);

            var updated_at_: any;
                updated_at_ = _data["updated_at"];
            this.updated_at(updated_at_);

        }
    }

    static fromJS(data: any): UserResponse {
        let result = new UserResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        let id_: any = this.id();
        data["id"] = id_;

        let email_: any = this.email();
        data["email"] = email_;

        let username_: any = this.username();
        data["username"] = username_;

        let created_at_: any = this.created_at();
        data["created_at"] = created_at_;

        let updated_at_: any = this.updated_at();
        data["updated_at"] = updated_at_;

        return data;
    }
}

export class DepartmentResponse {
    id = ko.observable<number>();
    num_dep = ko.observable<string>();
    dep_name = ko.observable<string>();
    region_name = ko.observable<string>();

    init(data?: any) {
        if (data !== undefined) {
            var id_: any;
                id_ = _data["id"];
            this.id(id_);

            var num_dep_: any;
                num_dep_ = _data["num_dep"];
            this.num_dep(num_dep_);

            var dep_name_: any;
                dep_name_ = _data["dep_name"];
            this.dep_name(dep_name_);

            var region_name_: any;
                region_name_ = _data["region_name"];
            this.region_name(region_name_);

        }
    }

    static fromJS(data: any): DepartmentResponse {
        let result = new DepartmentResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        let id_: any = this.id();
        data["id"] = id_;

        let num_dep_: any = this.num_dep();
        data["num_dep"] = num_dep_;

        let dep_name_: any = this.dep_name();
        data["dep_name"] = dep_name_;

        let region_name_: any = this.region_name();
        data["region_name"] = region_name_;

        return data;
    }
}

export class Emails {
    emails = ko.observableArray<any>([]);
    message = ko.observable<string>();
    subject = ko.observable<string>();
    view = ko.observable<string>();

    init(data?: any) {
        if (data !== undefined) {
            var emails_: any;
            if (Array.isArray(_data["emails"])) {
                emails_ = [] as any;
                for (let item of _data["emails"])
                    emails_!.push(item);
            }
            this.emails(emails_);

            var message_: any;
                message_ = _data["message"];
            this.message(message_);

            var subject_: any;
                subject_ = _data["subject"];
            this.subject(subject_);

            var view_: any;
                view_ = _data["view"];
            this.view(view_);

        }
    }

    static fromJS(data: any): Emails {
        let result = new Emails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        let emails_: any = this.emails();
        if (Array.isArray(emails_)) {
            data["emails"] = [];
            for (let item of emails_)
                data["emails"].push(item);
        }

        let message_: any = this.message();
        data["message"] = message_;

        let subject_: any = this.subject();
        data["subject"] = subject_;

        let view_: any = this.view();
        data["view"] = view_;

        return data;
    }
}

export class Email {
    email = ko.observable<string>();
    message = ko.observable<string>();
    subject = ko.observable<string>();
    view = ko.observable<string>();

    init(data?: any) {
        if (data !== undefined) {
            var email_: any;
                email_ = _data["email"];
            this.email(email_);

            var message_: any;
                message_ = _data["message"];
            this.message(message_);

            var subject_: any;
                subject_ = _data["subject"];
            this.subject(subject_);

            var view_: any;
                view_ = _data["view"];
            this.view(view_);

        }
    }

    static fromJS(data: any): Email {
        let result = new Email();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        let email_: any = this.email();
        data["email"] = email_;

        let message_: any = this.message();
        data["message"] = message_;

        let subject_: any = this.subject();
        data["subject"] = subject_;

        let view_: any = this.view();
        data["view"] = view_;

        return data;
    }
}

export class RegisterRole {
    id = ko.observable<number>();
    name = ko.observable<string>();
    description = ko.observable<string>();
    created_at = ko.observable<any>();
    updated_at = ko.observable<any>();

    init(data?: any) {
        if (data !== undefined) {
            var id_: any;
                id_ = _data["id"];
            this.id(id_);

            var name_: any;
                name_ = _data["name"];
            this.name(name_);

            var description_: any;
                description_ = _data["description"];
            this.description(description_);

            var created_at_: any;
                created_at_ = _data["created_at"];
            this.created_at(created_at_);

            var updated_at_: any;
                updated_at_ = _data["updated_at"];
            this.updated_at(updated_at_);

        }
    }

    static fromJS(data: any): RegisterRole {
        let result = new RegisterRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        let id_: any = this.id();
        data["id"] = id_;

        let name_: any = this.name();
        data["name"] = name_;

        let description_: any = this.description();
        data["description"] = description_;

        let created_at_: any = this.created_at();
        data["created_at"] = created_at_;

        let updated_at_: any = this.updated_at();
        data["updated_at"] = updated_at_;

        return data;
    }
}

export class RoleResponse {
    id = ko.observable<number>();
    name = ko.observable<string>();
    description = ko.observable<string>();
    created_at = ko.observable<any>();
    updated_at = ko.observable<any>();

    init(data?: any) {
        if (data !== undefined) {
            var id_: any;
                id_ = _data["id"];
            this.id(id_);

            var name_: any;
                name_ = _data["name"];
            this.name(name_);

            var description_: any;
                description_ = _data["description"];
            this.description(description_);

            var created_at_: any;
                created_at_ = _data["created_at"];
            this.created_at(created_at_);

            var updated_at_: any;
                updated_at_ = _data["updated_at"];
            this.updated_at(updated_at_);

        }
    }

    static fromJS(data: any): RoleResponse {
        let result = new RoleResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        let id_: any = this.id();
        data["id"] = id_;

        let name_: any = this.name();
        data["name"] = name_;

        let description_: any = this.description();
        data["description"] = description_;

        let created_at_: any = this.created_at();
        data["created_at"] = created_at_;

        let updated_at_: any = this.updated_at();
        data["updated_at"] = updated_at_;

        return data;
    }
}

export class ExecuteRole {
    success = ko.observable<boolean>();

    init(data?: any) {
        if (data !== undefined) {
            var success_: any;
                success_ = _data["success"];
            this.success(success_);

        }
    }

    static fromJS(data: any): ExecuteRole {
        let result = new ExecuteRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        let success_: any = this.success();
        data["success"] = success_;

        return data;
    }
}

export class GoogleHtmlUrl {

    init(data?: any) {
        if (data !== undefined) {
        }
    }

    static fromJS(data: any): GoogleHtmlUrl {
        let result = new GoogleHtmlUrl();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

C:\xampp\htdocs\adopte-un-pet\frontend\services\BaseClient.not